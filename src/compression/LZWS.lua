local BitWriter = require "io.BitWriter"

---@class LZWS
---@field compress function
local LZWS = {}

---Utility for sanity checking input
---@param param any object to be tested for integer
---@param paramName string parameter name
local function assert_is_int(param, paramName)
    assert(type(param) == "number" and math.floor(param) == param, paramName .. " must be an integer")
end

---Makes a new dictionary with 256 entries, for all characters
---@return DefaultDictionary dictionary Indices 0-255, with a .count field
local function makeDefaultCodeDictionary()
    ---@class DefaultDictionary
    ---@field count integer
    local default = {}
    for i = 0, 255 do default[i] = i end
    default.count = 256
    return default
end

---Writes header and codes for version 0 of LZWS content.
---@param writer BitWriter Utility to write bits with.
---@param codes table Array of integer codes where no integer should be greater than dictSize
---@param dictSize integer Size of the dictionary this set was compressed with
local function encodeVersion0ToWriter(writer, codes, dictSize)
    local bitsPerCode = math.ceil(math.log(dictSize, 2))
    assert(bitsPerCode <= 24, "Abnormally large code dictionary, aborting encoding")
    writer:writeBits(bitsPerCode, 5)
    writer:writeBits(#codes, 32)
    for i = 1, #codes do
        writer:writeBits(codes[i], bitsPerCode)
    end
end

---Encodes a string of compressed codes (characters range from 0 to 255)
---@param codes table An array of codes generated by LZWS.encode
---@param dictSize integer Dictionary size
---@return string string Compressed codes
local function encodeToString(codes, dictSize)
    local writer = BitWriter.new()
    writer:writeBits(0, 3) -- Version 0
    encodeVersion0ToWriter(writer, codes, dictSize)
    return tostring(writer)
end

---Compresses any string into a smaller string
---The return value not safe to send over emitters in Dual Universe since they cannot handle \0 chars.
---Encode the resulting string with Z85 for example before sending (adds 20% to your compressed string size).
---@param s string The string to be compressed.
---@param maxBitWidth integer|nil Optional max bit width of codes. Valid range is 9-24. Default is 12 which makes for 4096 entries in the dictionary.
---@return string string A compressed string which characters may occupy all ranges 0-255.
function LZWS.compress(s, maxBitWidth)
    assert(type(s) == "string", "s must be a string")
    maxBitWidth = maxBitWidth or 12
    assert_is_int(maxBitWidth, "maxBitWidth")
    assert(maxBitWidth >= 9 and maxBitWidth <= 24, "bitCount has to be in range 9 to 24")

    local codeDictionary = makeDefaultCodeDictionary()
    local codes = {}
    local maxCodes = 2 ^ maxBitWidth
    local currentWord = 0
    local hasUnrecordedWord = false

    local bytes = table.pack(s:byte(1, #s))

    for i = 1, #bytes do
        local nextCharacter = bytes[i]
        local newWord = currentWord << 8 | nextCharacter
        if codeDictionary[newWord] and #codes < maxCodes then
            currentWord = newWord
            hasUnrecordedWord = true
        else
            codeDictionary[newWord] = codeDictionary.count
            table.insert(codes, codeDictionary[currentWord])
            codeDictionary.count = codeDictionary.count + 1
            currentWord = nextCharacter
            hasUnrecordedWord = false
        end
    end

    if hasUnrecordedWord then
        table.insert(codes, codeDictionary[currentWord])
    end

    return encodeToString(codes, codeDictionary.count)
end

return LZWS
