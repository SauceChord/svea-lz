---@class LZWS Provides compression and decompression for strings
---@field compress function Provides a compressed string
---@field decompress function Provides a decompressed string from a previous call to LZWS.compress
local LZWS = {}

require "asserts.Extra"
local BitWriter = require "io.BitWriter"
local BitReader = require "io.BitReader"

local function defaultStringToCodeTable()
    local t = {}
    for i = 0, 255 do
        t[string.char(i)] = i
    end
    return t, 256
end

local function defaultCodeToStringTable()
    local t = {}
    for i = 0, 255 do
        t[i] = string.char(i)
    end
    return t, 256
end

---Writes header and codes for version 0 of LZWS content.
---@param writer BitWriter Utility to write bits with.
---@param codes table Array of integer codes where no integer should be greater than dictSize
---@param dictSize integer Size of the dictionary this set was compressed with
local function encodeVersion0ToWriter(writer, codes, dictSize)
    local bitsPerCode = math.ceil(math.log(dictSize, 2))
    assert_is_in_range(8, 24, bitsPerCode, "bitsPerCode")
    writer:writeBits(bitsPerCode, 5)
    writer:writeBits(#codes, 32)
    for i = 1, #codes do
        writer:writeBits(codes[i], bitsPerCode)
    end
end

---Encodes a string of compressed codes (characters range from 0 to 255)
---@param codes table An array of codes generated by LZWS.encode
---@param dictSize integer Dictionary size
---@return string string Compressed codes
local function encodeToString(codes, dictSize)
    local writer = BitWriter.new()
    local version = 0
    writer:writeBits(version, 3)
    encodeVersion0ToWriter(writer, codes, dictSize)
    return tostring(writer)
end

---Compresses any string into a smaller string
---The return value not safe to send over emitters in Dual Universe since they cannot handle \0 chars.
---Encode the resulting string with Z85 for example before sending (adds 20% to your compressed string size).
---@param s string The string to be compressed.
---@param maxBitWidth integer|nil Optional max bit width of codes. Valid range is 9-24. Default is 12 which makes for 4096 entries in the dictionary.
---@return string string A compressed string which characters may occupy all ranges 0-255.
function LZWS.compress(s, maxBitWidth)
    maxBitWidth = maxBitWidth or 12
    assert_is_int(maxBitWidth, "maxBitWidth")
    assert_is_in_range(9, 24, maxBitWidth, "maxBitWidth")
    assert_is_string(s, "s")

    local stringToCode, newCode = defaultStringToCodeTable()
    local output = {}

    if #s == 0 then
        return encodeToString(output, newCode)
    end

    local maxCodes = 2 ^ maxBitWidth
    local w = ""
    local K = nil
    local wK = nil

    for i = 1, #s do
        K = s:sub(i, i)
        wK = w .. K
        if newCode < maxCodes and stringToCode[wK] then
            w = wK
        else
            table.insert(output, stringToCode[w])
            -- note: a few extra strings may be stored due to no 
            --       "newCode < maxCodes" branch, but I left code 
            --        readable for once
            stringToCode[wK] = newCode
            newCode = newCode + 1
            --
            w = K
        end
    end

    table.insert(output, stringToCode[w])

    return encodeToString(output, newCode)
end

---Decodes version 0 of LZWS
---@param reader BitReader a reader pointing to the data
---@return string result the decoded string
local function decodeVersion0(reader)
    local codeWidth = reader:readBits(5)
    local codeWords = reader:readBits(32)

    if codeWords == 0 then
        return ""
    end

    local codeToString, newCode = defaultCodeToStringTable()

    -- Read first code outside the loop. Because...
    -- I haven't found a way to generalize for cases like { 97, 256 } ('aaa')
    -- and the 'XYZYZYXXYZXYZYYYYYYXYZY' test sample.
    local code = reader:readBits(codeWidth)
    local word = codeToString[code]
    local lastWord = word
    local output = {}
    table.insert(output, word)

    -- Read the remaining codeWords
    for i = 2, codeWords do
        code = reader:readBits(codeWidth)
        word = codeToString[code] or lastWord .. lastWord:sub(1, 1)
        codeToString[newCode] = lastWord .. word:sub(1, 1)
        newCode = newCode + 1
        table.insert(output, word)
        lastWord = word
    end

    return table.concat(output)
end

---Decompresses a LZWS compressed string
---@param s string A LZWS compressed string
---@return string result A decompressed string
function LZWS.decompress(s)
    local reader = BitReader.new(s)
    local version = reader:readBits(3)
    assert(version == 0, "LZWS version must be 0 but got " .. version)
    return decodeVersion0(reader)
end

return LZWS
